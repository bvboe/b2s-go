#!/bin/bash
# agent-integration-test: Validate bjorn2scan-agent results against direct syft/grype execution
#
# This script:
# 1. Starts the bjorn2scan-agent test container
# 2. Runs test images inside the container's Docker daemon
# 3. Runs syft and grype locally on the same images
# 4. Waits for the agent to scan them
# 5. Compares results (packages and CVEs)
# 6. Reports any differences

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AGENT_DIR="${SCRIPT_DIR}/../bjorn2scan-agent"
TEST_CASES_FILE="${SCRIPT_DIR}/test-cases.txt"
AGENT_API_URL="http://localhost:9999"
TIMEOUT=600  # 10 minutes
POLL_INTERVAL=5  # Poll every 5 seconds
TEMP_DIR=$(mktemp -d)
CONTAINER_NAME="bjorn2scan-test"

# Counters
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Track containers created inside the test container
CREATED_CONTAINERS=()

# Cleanup function
cleanup() {
    echo ""
    echo "Cleaning up..."

    # Clean up Docker containers inside test container
    if [[ ${#CREATED_CONTAINERS[@]} -gt 0 ]]; then
        echo "Cleaning up test containers inside agent..."
        for container in "${CREATED_CONTAINERS[@]}"; do
            docker exec "$CONTAINER_NAME" docker rm -f "$container" 2>/dev/null || true
        done
    fi

    # Stop and remove test container
    echo "Stopping agent test container..."
    cd "$AGENT_DIR"
    ./test-container.sh clean >/dev/null 2>&1 || true

    # Clean up temp directory
    rm -rf "$TEMP_DIR"

    # Summary
    echo ""
    echo "========================================"
    echo "Agent Integration Test Summary"
    echo "========================================"
    echo "Total tests: $TOTAL_TESTS"
    echo -e "${GREEN}Passed: $PASSED_TESTS${NC}"
    if [[ $FAILED_TESTS -gt 0 ]]; then
        echo -e "${RED}Failed: $FAILED_TESTS${NC}"
    else
        echo "Failed: 0"
    fi
    echo "========================================"

    if [[ $FAILED_TESTS -gt 0 ]]; then
        exit 1
    fi
}

trap cleanup EXIT INT TERM

# Check prerequisites
check_prerequisites() {
    echo "Checking prerequisites..."

    local missing=()

    command -v syft >/dev/null 2>&1 || missing+=("syft")
    command -v grype >/dev/null 2>&1 || missing+=("grype")
    command -v docker >/dev/null 2>&1 || missing+=("docker")
    command -v jq >/dev/null 2>&1 || missing+=("jq")
    command -v curl >/dev/null 2>&1 || missing+=("curl")

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}ERROR: Missing required tools: ${missing[*]}${NC}"
        echo "Please install them and try again."
        exit 1
    fi

    # Check if test-container.sh exists
    if [[ ! -f "$AGENT_DIR/test-container.sh" ]]; then
        echo -e "${RED}ERROR: test-container.sh not found at $AGENT_DIR${NC}"
        exit 1
    fi

    echo -e "${GREEN}✓ All prerequisites installed${NC}"
}

# Start the agent test container
start_agent_container() {
    echo "Starting bjorn2scan-agent test container..."

    cd "$AGENT_DIR"

    # Check if image exists, only build if it doesn't (or if REBUILD=1 is set)
    local IMAGE_NAME="bjorn2scan-agent:test-local"
    if [[ "${REBUILD:-0}" == "1" ]] || ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
        echo "Building test container image..."
        if ! ./test-container.sh build; then
            echo -e "${RED}ERROR: Failed to build test container${NC}"
            exit 1
        fi
    else
        echo "Using existing image: $IMAGE_NAME (set REBUILD=1 to force rebuild)"
    fi

    # Stop and remove existing container if running
    if docker ps -a --format '{{.Names}}' | grep -q "^bjorn2scan-test$"; then
        echo "Stopping and removing existing container..."
        docker stop bjorn2scan-test 2>/dev/null || true
        docker rm bjorn2scan-test 2>/dev/null || true
    fi

    # Start the container
    echo "Starting container..."
    if ! docker run -d \
        --name bjorn2scan-test \
        --privileged \
        --cgroupns=host \
        -v /sys/fs/cgroup:/sys/fs/cgroup:rw \
        -p 9999:9999 \
        "$IMAGE_NAME" >/dev/null; then
        echo -e "${RED}ERROR: Failed to start container${NC}"
        exit 1
    fi

    # Wait for agent to be ready
    echo "Waiting for agent API to be ready..."
    for i in {1..60}; do
        if curl -sf "$AGENT_API_URL/health" >/dev/null 2>&1; then
            echo -e "${GREEN}✓ Agent is ready${NC}"
            return 0
        fi
        sleep 2
    done

    echo -e "${RED}ERROR: Agent failed to start${NC}"
    exit 1
}

# Read test cases from file
read_test_cases() {
    if [[ ! -f "$TEST_CASES_FILE" ]]; then
        echo -e "${RED}ERROR: Test cases file not found: $TEST_CASES_FILE${NC}"
        exit 1
    fi

    # Read file, skip comments and empty lines
    grep -v '^#' "$TEST_CASES_FILE" | grep -v '^[[:space:]]*$' || true
}

# Run test image inside agent's Docker
run_image_in_agent() {
    local image=$1
    local container_name="test-$(echo "$image" | tr ':/' '--')-$$"

    echo "Pulling image inside agent: $image" >&2
    if ! docker exec "$CONTAINER_NAME" docker pull "$image" >&2; then
        echo -e "${YELLOW}Warning: Failed to pull image${NC}" >&2
        return 1
    fi

    echo "Running container: $container_name" >&2

    local output
    if ! output=$(docker exec "$CONTAINER_NAME" docker run -d --name "$container_name" "$image" sleep 3600 2>&1); then
        echo -e "${YELLOW}Warning: Failed to run container${NC}" >&2
        return 1
    fi

    # Extract container ID (last line, should be hex string)
    # Docker warnings may appear before the ID, so take the last line
    local container_id
    container_id=$(echo "$output" | tail -n 1)

    # Validate it looks like a container ID (hex string, 12 or 64 chars)
    if [[ ! "$container_id" =~ ^[0-9a-f]{12,}$ ]]; then
        echo -e "${YELLOW}Warning: Invalid container ID format: $container_id${NC}" >&2
        echo "Full output:" >&2
        echo "$output" >&2
        return 1
    fi

    # Track for cleanup
    CREATED_CONTAINERS+=("$container_name")

    echo "$container_id"
}

# Wait for container to be running
wait_for_container() {
    local container_id=$1

    echo "Waiting for container to be running..."

    for i in {1..30}; do
        local status
        status=$(docker exec "$CONTAINER_NAME" docker inspect --format='{{.State.Status}}' "$container_id" 2>/dev/null || echo "")

        if [[ "$status" == "running" ]]; then
            echo -e "${GREEN}✓ Container is running${NC}"
            return 0
        fi

        sleep 1
    done

    echo -e "${YELLOW}Warning: Container did not start within timeout${NC}"
    return 1
}

# Get image digest from container
get_image_digest() {
    local container_id=$1

    docker exec "$CONTAINER_NAME" docker inspect --format='{{.Image}}' "$container_id" 2>/dev/null | sed 's/sha256://'
}

# Run syft locally
run_syft_local() {
    local image=$1
    local output_file=$2

    echo "Running syft locally on $image..."
    if syft "$image" -o json > "$output_file" 2>/dev/null; then
        echo -e "${GREEN}✓ Syft completed${NC}"
        return 0
    else
        echo -e "${YELLOW}Warning: Syft failed${NC}"
        return 1
    fi
}

# Run grype locally
run_grype_local() {
    local sbom_file=$1
    local output_file=$2

    echo "Running grype locally..."
    if grype "sbom:$sbom_file" -o json > "$output_file" 2>/dev/null; then
        echo -e "${GREEN}✓ Grype completed${NC}"
        return 0
    else
        echo -e "${YELLOW}Warning: Grype failed${NC}"
        return 1
    fi
}

# Wait for agent to complete scanning
wait_for_scan_completion() {
    local image_digest=$1

    echo "Waiting for agent to complete scanning (digest: sha256:${image_digest:0:20}...)..."

    local elapsed=0
    while [[ $elapsed -lt $TIMEOUT ]]; do
        # Try to find the image by digest
        local response
        response=$(curl -s "$AGENT_API_URL/api/images/sha256:$image_digest" 2>/dev/null || echo "{}")

        local status
        status=$(echo "$response" | jq -r '.status_description // empty' 2>/dev/null || echo "")

        if [[ "$status" == "Scan complete" ]]; then
            echo -e "${GREEN}✓ Agent scan completed${NC}"
            return 0
        elif [[ "$status" == "Scan failed"* ]]; then
            echo -e "${YELLOW}Warning: Agent scan failed: $status${NC}"
            return 1
        elif [[ -n "$status" ]]; then
            echo "  Status: $status (elapsed: ${elapsed}s)"
        fi

        sleep $POLL_INTERVAL
        elapsed=$((elapsed + POLL_INTERVAL))
    done

    echo -e "${YELLOW}Warning: Timeout waiting for scan completion${NC}"
    return 1
}

# Fetch agent SBOM
fetch_agent_sbom() {
    local image_digest=$1
    local output_file=$2

    echo "Fetching SBOM from agent..."

    # Fetch all packages by iterating through pages if needed
    local all_packages="[]"
    local page=1
    local total_pages=1
    local total_count=0

    while [[ $page -le $total_pages ]]; do
        local response
        response=$(curl -s "$AGENT_API_URL/api/images/sha256:$image_digest/packages?page=$page&pageSize=1000")

        if [[ -z "$response" ]]; then
            echo -e "${YELLOW}Warning: Empty response from API${NC}"
            return 1
        fi

        # Extract pagination info
        total_pages=$(echo "$response" | jq -r '.totalPages // 1')
        total_count=$(echo "$response" | jq -r '.totalCount // 0')

        # Merge packages from this page
        local page_packages
        page_packages=$(echo "$response" | jq -r '.packages // []')
        all_packages=$(echo "$all_packages" "$page_packages" | jq -s 'add')

        page=$((page + 1))
    done

    # Create final output with all packages
    echo "{\"packages\": $all_packages, \"totalCount\": $total_count}" > "$output_file"

    if [[ -s "$output_file" ]]; then
        local fetched_count
        fetched_count=$(echo "$all_packages" | jq 'length')
        echo "  Fetched $fetched_count/$total_count packages from API ($(($total_pages)) pages)"
        echo -e "${GREEN}✓ SBOM fetched${NC}"
        return 0
    else
        echo -e "${YELLOW}Warning: Failed to fetch SBOM${NC}"
        return 1
    fi
}

# Fetch agent vulnerabilities
fetch_agent_vulns() {
    local image_digest=$1
    local output_file=$2

    echo "Fetching vulnerabilities from agent..."

    # Fetch all vulnerabilities by iterating through pages if needed
    local all_vulns="[]"
    local page=1
    local total_pages=1
    local total_count=0

    while [[ $page -le $total_pages ]]; do
        local response
        response=$(curl -s "$AGENT_API_URL/api/images/sha256:$image_digest/vulnerabilities?page=$page&pageSize=1000")

        if [[ -z "$response" ]]; then
            echo -e "${YELLOW}Warning: Empty response from API${NC}"
            return 1
        fi

        # Extract pagination info
        total_pages=$(echo "$response" | jq -r '.totalPages // 1')
        total_count=$(echo "$response" | jq -r '.totalCount // 0')

        # Merge vulnerabilities from this page
        local page_vulns
        page_vulns=$(echo "$response" | jq -r '.vulnerabilities // []')
        all_vulns=$(echo "$all_vulns" "$page_vulns" | jq -s 'add')

        page=$((page + 1))
    done

    # Create final output with all vulnerabilities
    echo "{\"vulnerabilities\": $all_vulns, \"totalCount\": $total_count}" > "$output_file"

    if [[ -s "$output_file" ]]; then
        local fetched_count
        fetched_count=$(echo "$all_vulns" | jq 'length')
        echo "  Fetched $fetched_count/$total_count vulnerabilities from API ($(($total_pages)) pages)"
        echo -e "${GREEN}✓ Vulnerabilities fetched${NC}"
        return 0
    else
        echo -e "${YELLOW}Warning: Failed to fetch vulnerabilities${NC}"
        return 1
    fi
}

# Compare SBOM packages
compare_sbom() {
    local syft_file=$1
    local agent_file=$2

    echo "Comparing SBOM packages..."

    # Extract package name+version from syft output
    local syft_packages
    syft_packages=$(jq -r '.artifacts[]? | "\(.name)@\(.version)"' "$syft_file" 2>/dev/null | sort -u || echo "")

    # Extract package name+version from agent output
    local agent_packages
    agent_packages=$(jq -r '.packages[]? | "\(.name)@\(.version)"' "$agent_file" 2>/dev/null | sort -u || echo "")

    local syft_count
    syft_count=$(echo "$syft_packages" | grep -c . || echo "0")
    local agent_count
    agent_count=$(echo "$agent_packages" | grep -c . || echo "0")

    echo "  Syft packages: $syft_count"
    echo "  Agent packages: $agent_count"

    # Find differences
    local missing_in_agent
    missing_in_agent=$(comm -23 <(echo "$syft_packages") <(echo "$agent_packages") | head -10)

    local extra_in_agent
    extra_in_agent=$(comm -13 <(echo "$syft_packages") <(echo "$agent_packages") | head -10)

    local has_differences=false

    if [[ -n "$missing_in_agent" ]]; then
        echo -e "${YELLOW}  ⚠ Packages in syft but missing in agent:${NC}"
        echo "$missing_in_agent" | head -10 | sed 's/^/    /'
        has_differences=true
    fi

    if [[ -n "$extra_in_agent" ]]; then
        echo -e "${YELLOW}  ⚠ Extra packages in agent not in syft:${NC}"
        echo "$extra_in_agent" | head -10 | sed 's/^/    /'
        has_differences=true
    fi

    if [[ "$has_differences" == "false" ]]; then
        echo -e "${GREEN}  ✓ SBOM packages match${NC}"
        return 0
    else
        return 1
    fi
}

# Compare vulnerabilities
compare_vulnerabilities() {
    local grype_file=$1
    local agent_file=$2

    echo "Comparing vulnerabilities..."

    # Extract CVE IDs from grype output
    local grype_cves
    grype_cves=$(jq -r '.matches[]?.vulnerability.id // empty' "$grype_file" 2>/dev/null | sort -u || echo "")

    # Extract CVE IDs from agent output
    local agent_cves
    agent_cves=$(jq -r '.vulnerabilities[]?.vulnerability_id // empty' "$agent_file" 2>/dev/null | sort -u || echo "")

    local grype_count
    grype_count=$(echo "$grype_cves" | grep -c . || echo "0")
    local agent_count
    agent_count=$(echo "$agent_cves" | grep -c . || echo "0")

    echo "  Grype CVEs: $grype_count"
    echo "  Agent CVEs: $agent_count"

    # Find differences
    local missing_in_agent
    missing_in_agent=$(comm -23 <(echo "$grype_cves") <(echo "$agent_cves") | head -10)

    local extra_in_agent
    extra_in_agent=$(comm -13 <(echo "$grype_cves") <(echo "$agent_cves") | head -10)

    local has_differences=false

    if [[ -n "$missing_in_agent" ]]; then
        echo -e "${YELLOW}  ⚠ CVEs in grype but missing in agent:${NC}"
        echo "$missing_in_agent" | head -10 | sed 's/^/    /'
        has_differences=true
    fi

    if [[ -n "$extra_in_agent" ]]; then
        echo -e "${YELLOW}  ⚠ Extra CVEs in agent not in grype:${NC}"
        echo "$extra_in_agent" | head -10 | sed 's/^/    /'
        has_differences=true
    fi

    if [[ "$has_differences" == "false" ]]; then
        echo -e "${GREEN}  ✓ Vulnerabilities match${NC}"
        return 0
    else
        return 1
    fi
}

# Stop and remove container inside agent
delete_test_container() {
    local container_id=$1

    echo "Removing test container..."
    docker exec "$CONTAINER_NAME" docker rm -f "$container_id" >/dev/null 2>&1 || true
}

# Test a single image
test_image() {
    local image=$1

    echo ""
    echo "========================================"
    echo "Testing: $image"
    echo "========================================"

    TOTAL_TESTS=$((TOTAL_TESTS + 1))

    local test_dir="$TEMP_DIR/$TOTAL_TESTS"
    mkdir -p "$test_dir"

    local container_id=""
    local test_passed=true

    # Run container inside agent's Docker
    if ! container_id=$(run_image_in_agent "$image"); then
        echo -e "${RED}✗ Failed to run container${NC}"
        FAILED_TESTS=$((FAILED_TESTS + 1))
        return 1
    fi

    echo "Container ID: ${container_id:0:12}"

    # Wait for container to be running
    if ! wait_for_container "$container_id"; then
        echo -e "${YELLOW}⚠ Container not running, skipping test${NC}"
        delete_test_container "$container_id"
        FAILED_TESTS=$((FAILED_TESTS + 1))
        return 1
    fi

    # Get image digest
    local image_digest
    image_digest=$(get_image_digest "$container_id")
    echo "Image digest: sha256:$image_digest"

    # Run syft locally
    if ! run_syft_local "$image" "$test_dir/syft.json"; then
        test_passed=false
    fi

    # Run grype locally
    if [[ -f "$test_dir/syft.json" ]]; then
        if ! run_grype_local "$test_dir/syft.json" "$test_dir/grype.json"; then
            test_passed=false
        fi
    fi

    # Wait for agent to scan
    if ! wait_for_scan_completion "$image_digest"; then
        test_passed=false
    fi

    # Fetch agent results
    if ! fetch_agent_sbom "$image_digest" "$test_dir/agent-sbom.json"; then
        test_passed=false
    fi

    if ! fetch_agent_vulns "$image_digest" "$test_dir/agent-vulns.json"; then
        test_passed=false
    fi

    # Compare results
    if [[ -f "$test_dir/syft.json" ]] && [[ -f "$test_dir/agent-sbom.json" ]]; then
        if ! compare_sbom "$test_dir/syft.json" "$test_dir/agent-sbom.json"; then
            test_passed=false
        fi
    fi

    if [[ -f "$test_dir/grype.json" ]] && [[ -f "$test_dir/agent-vulns.json" ]]; then
        if ! compare_vulnerabilities "$test_dir/grype.json" "$test_dir/agent-vulns.json"; then
            test_passed=false
        fi
    fi

    # Clean up container
    delete_test_container "$container_id"

    # Update counters
    if [[ "$test_passed" == "true" ]]; then
        echo -e "${GREEN}✓ Test PASSED for $image${NC}"
        PASSED_TESTS=$((PASSED_TESTS + 1))
    else
        echo -e "${RED}✗ Test FAILED for $image${NC}"
        FAILED_TESTS=$((FAILED_TESTS + 1))
    fi
}

# Main function
main() {
    echo "========================================"
    echo "bjorn2scan-agent Integration Test"
    echo "========================================"

    check_prerequisites
    start_agent_container

    # Read test cases
    local test_cases
    test_cases=$(read_test_cases)

    if [[ -z "$test_cases" ]]; then
        echo -e "${RED}ERROR: No test cases found in $TEST_CASES_FILE${NC}"
        exit 1
    fi

    echo ""
    echo "Found $(echo "$test_cases" | wc -l) test case(s)"
    echo ""

    # Test each image
    while IFS= read -r image; do
        test_image "$image"
    done <<< "$test_cases"
}

main "$@"
